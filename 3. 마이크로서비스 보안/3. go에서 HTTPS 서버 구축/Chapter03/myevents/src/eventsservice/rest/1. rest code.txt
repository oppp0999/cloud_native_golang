---ch2 rest.go---
18. -> 표준 라이브러리의 HTTP Go 패키지에 속한 ListenAndServe() -> 첫번째 인수 endpoint는 웹서버가 요청대기 예를들어 로컬포트 8181에서 요청 대기를 원하면 엔드포인트는 :8181이나 Localhost:8181이 된다.
두번째 인수 r은 HTTP라우트와 핸들러를 기술하는 객체이다. 객체는 고릴라mux패키지에 의해 생성됨(13 code)
-----------------

웹서버를 HTTP에서 HTTPS로 전환시키려면 하나의 단순한 변경을 수행
22. -> http.ListenAndServe(endpoint, r) -> http.ListenAndServeTLS(endpoint, "cert.pem", "key.pem", r)
이전보다 더 많은 인수를 취함. 이들은 단순히 디지털 인증서 파일 이름과 개인키 파일 이름이다.
첫 번째 인수 : 요청 대기하는 웹서버
마지막 인수 : 핸들러 객체

인증서와 개인키를 생성하였고 여기서 해야할 전부는 올바른 파일들을 가리키는 것을 보장하는 것

HTTP와 HTTPS 양쪽 모두 지원하고싶다면 함수를 둘 다 실행시키는 방법도 있다.
요청 대기 포트를 다르게함으로써 HTTP는 endpoint를 -> http.ListenAndServe(endpoint, r)
HTTPS에 대해 로컬 요청 대기는 tlsendpoint라는 변수에 저장 - http.ListenAndServeTLS(tlsendpoint, "cert.pem", "key.pem", r)

하지마 여기서
-> 둘 다 함수를 정지시키면 이들을 호출할 때마다 에러가 발생하기 전까지 현재의 고루틴을 무기한으로 막는다.
결국 양쪽 함수 모두를 동일한 고루틴에서 호출할 수 없다는 것
동시작업을 이용하기 위해 사용

21~26. ->그 해결책은 고루틴에서 함수들 중 하나를 호출하고 이는 함수 이름 앞에 단어 go를 위치시켜 간단히 달성
즉 -> 두 개의 고루틴 간에 상호 통신을 할 수 있게 만듦
대구의 go채널을 생성하고 각 하나씩 에러 객체를 담는다. 하나는 에러 관찰, 하나는 에러 보고

ServeAPI를 보면 에러 채널들을 생성하고 두 개의 분리된 고루틴에서 HTTP 패키지들을 호출 및 에러 채널 반환.
반횐된 에러처리는 main에서 처리.