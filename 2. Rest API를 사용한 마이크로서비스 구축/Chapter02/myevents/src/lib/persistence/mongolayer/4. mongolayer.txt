//지속성 계층 설명

mgo는 go 언어로 작성된 몽고 DB 드라이버
몽고db 지속성 계층을 관리하는데 사용하는 패키지 이름은 mongolay

몽고db에 있는 데이터베이스 이름은 myevents가 될 것이다.
사용할 모음들의 이름은 데이터베이스상의 사용자 모음은 users, 이벤트 모음은 events가 된다.
----------------------------------------------------------------------
----------------------------------------------------------------------
10 -> mgo패키지의 기능을 외부로 노출시키고자 mgo 패키지에 속한 데이터베이스 세션 객체를 활용할 필요가 있다.
이세션 객체 타입은 *mgo.Session이라한다.

16 -> 내부 코드에서 *mgo.Session을 이용하고자 MongoDBLayer라는 struct타입으로 감싼다.

20 -> 문자열타입의 단일 인수를 취하는 NewMongoDBLayer라는 생성자 함수를 만들었다.
이 인수는 연결 문자열로 몽고DB 데이터베이스와 연결을 맺는 데 필요한 정보를 나타낸다.
실질적인 DatabaseHandler 인터베이스를 구현
-go언어에서 인터페이스를 구현할 때 일반적으로 포인터 타입의 사용이 선호된다. 포인터를 활용할 때 해당 객체의 전체 영역을 복사하는 것과는 달리 본 객체의 원래 메모리 주소를 참조하기 때문
- databasehandler 인터페이스에 대한 구현자 객체 타입은 mongodblayer구조체에 대한 포인터나 단순히 *mongodblayer가 될 필요가 있다.
-하지만 이 인터페이스 구현을 시작하기 전에 *mongodblayer 타입의 객체를 반환하는 생성자 함수를 만들어야함.
- 새로운 객체를 생성함에 따라 필요한 초기화 코드도 실행할 수 있음

로컬호스트 연결이면 연결 문자열 mongodb://127.0.0.1 -> 기본포트 27017

mgo.Dial() -> 몽고 DB연결 세션을 반환한다. (*mgo.Session 객체와 error 객체의 결과를 반환)
끝부분에서 MongoDBLayer에 포인터 타입의 갓 생성된 객체를 반환하고자 구조체 리터럴을 사용하고 새롭게 생성된 *mgo.Session객체를 주관하게 된다.

---
27 -> 이 메서드는 persistence.event 타입의 인수를 취하고 이전에 다룬 이벤트로부터 기대되는 정보를 모델링한다.
해당 이벤트 Id를 나타내는 바이트 슬라이스와 아무런 에러가 없으면 Nil이 되는 에러 객체를 반환한다.
28 -> 첫 줄에서 이 메서드는 연결 풀에서 새로운 데이터베이스 세션을 가져오도록 돕고자 코드에서 구현된 헬퍼메서드다 -> 67
즉, 데이터베이스 연결. 풀에서 동작하는 *mgo.session 객체를 갖게 됐다. 첫 번째로 해야 할 일은 addEvent()메서드를 빠져나간 후에 이 세션이 mgo 데이터베이스 연결 풀로 다시 반환됨을 보장하고자 defer s.close()를 호출
다음으로 event 인수 객체에 의해 제공되는 이벤트 id가 유효한지 bson.objectid 타입인지 확인, 이는 유효한 몽고 db id인지 아닌지 탐시 할 수 있다.
유효하지 않아뎜 bson.newobjectid()함수 호출을 사용해서 자신의 것 하나를 생성할 것이다. 이후 그 이벤트 내의 장소에 내장된 객체로 동일 패턴을 반복할 것이다.
마지막 끝부분에는 2가지 결과를 반환, 첫번째는 추가된 이벤트의 이벤트 id 두번째는 이벤트 삽입 작업의 결과를 나태는 에러 객체. 몽고 db 데이터베이스에 이벤트 객체를 삽입하고자 s 변수에 있는 세션 객체를 사용할 것
이후에 이벤트들의 모음을 나타내는 객체를 얻고자 s.DB(DB).C(EVENTS)를 호출 이 객체는 *mgo.collection 타입이 될 것이다. 
DB()메서드는 데이터베이스 접근에 도움을 준다. C() 메서드는 모음 접근에 도움을 주고 여기에 이벤트들의 모음 이름을 갖는 EVENTS 상수를 준다.
Event 객체를 가진 모음 객체의 Insert() 메서드 호출 이는 즉 s.DB(DB).C(EVENTS).Insert(e) 와 같다 ->새로운 문서 삽입할 때 필요

------
42 -> 해당 ID 데이터베이스의 특정 이벤트 정보를 가져오고자 사용하는 것으로 다음과 같다.
bson.ObjectId 타입 대신 해당 ID가 어떻게 한 바이트 슬라이스로 전달되는지 주목 -> DatabaseHandler 인터베이스에 있는 FindEvent() 메서드가 가능한 한 포괄적으로 유지되는 것을 보장
예를 들면 몽고DB의 세계에서 ID는 bson.ObjectId 타입이 될 것을 알고 있다 그러나 지금 MySQL 데이터베이스 계층을 구현하고 싶다면 FindEvent()로 전달된 ID 인수 타입이 bson.ObjectId인 것은 말이 되지 않을 것이다.
따라서 ID인수를 나타내고자 []byte 타입을 선택한 것이다.
--> 원칙적으로 바이트 슬라이드 id를 나타낼 수 있는 어떤 다른 타입으로도 변환할 수 있어야 한다.
[[[[[또한 주목해야 할 점은 빈(empty) 인터페이스 타입(interface{})을 선택할 수도 있었으며 이는 Go에서 어떤 다른 타입으로도 변환이 될 수 있다는 것이다.]]]]]
43 -> 이전과 같이 mgoLayer.getFreshSession()을 사용해 연결 풀에서 새로운 세션을 얻음.
44 ->세션 작업 종류 후 연결 풀로 반납되는 것을 보장하고자 defer s.Close()를 호출
45 -> 빈 이벤트 객체 생성
47 -> 몽고DB에 있는 이벤트들의 모음에 접근하고자 s.DB(DB).C(EVENTS)를 사용
FindId() 메서드가 있는데, mgo의 *mgoCollection 객체에 의해 지원된다.
이 메서드는 인자로 bson.ObjectId 타입의 객체를 취하고 나서 원하는 ID로 문서를 검색
FindId()는 *mgo.Query 타입의 객체를 반환 -> mgo에서의 공통 타입, 이전에 생성했던 e 객체에 가져온 문서 데이터를 넣고자 *mgo.Query 타입에 속하는 one()메서드를 호출 -> 인수로 레퍼런스를 e에 전달하는 것이 필요
이렇게 함으로서 e는 원하는 ID로 가져온 문서의 데이터를 얻게 된다. 작업이 실패하면 One() 메서드는 에러 정보를 담고 있는 error 객체를 반환 그렇지 않으면 One()은 nil를 반납
48 -> 이벤트 객체와 error 객체를 반납
-------

51 -> 몽고 DB 데이터베이스에서 해당 이름으로 하나의 이벤트를 가져오는 메서드 (두 가지를 제외하고 FindEvent() 메서드와 유사) 차이점 - 1. string으로 받음 2. Id 대신 name으로 받음 3. FindId대신 Find 메서드 사용
55 -> Find() 메서는 몽고 DB에서 전달하고자 하는 질의를 나타내는 인수를 취한다.
bson 패키지는 bson.M이라는 타입을 제공한다. 이 타입은 기본적으로 찾고 싶은 질의 매개변수들을 나타내는 데 사용할 수 있는 맵이다. 이 코드 경우에는 FindEventByName에 인수로 전달된 이름을 찾고 있다.
데이터베이스의 이벤트 모음에 있는 이름 필드는 단순히 name으로 코드화되고 하나의 인수로 전달된 변수의 이름은 name이다. 해당 질의는 결국 bson.M{"name": name} 가 된다.

--------

59 -> 이 메서드는 데이터베이스에 있는 이용할 수 있는 모든 이벤트를 반환한다. ( 몽고DB 데이터베이스에서 전체 이벤트 모음을 반환하는 것이다 )
FindEventByname()과 거의 코드가 유사하다.
차이점
1. 다른 메서드와 달리 어떤 인수도 취하지 않는다는 점.
2. 단일 이벤트 객체 대신 이벤트 객체들의 슬라이스에 넣어질 질의 결과가 필요 -> 반환 타입으로 persistence.Event 대신 []persistence.Event를 사용
3. Find()메서드가 bson.M대신 nil인수를 사용
63 -> Find()가 nil 인수를 가질 때 연관된 몽고 DB 모음에서 찾아진 모든 것을 반환, 또한 Find() 후 One() 대신 All()을 사용한 것에 주목
- - - 이는 한 개가 아닌 다수의 결과들을 기대하기 때문 


---
67 -> session.copy mgo 패키지 연결 풀에서 새로운 세션을 요청할 때마다 호출되는 메서드
즉 getFreshSession()는 session.copy()를 호출하는 헬퍼 메서드이고 그 결과 세션을 반환
