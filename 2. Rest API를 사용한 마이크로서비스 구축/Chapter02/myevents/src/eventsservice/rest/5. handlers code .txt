-------------------
2.
-------------------
특징
1.지속성 계층
지속성 계층은 설계 할 때 첫 번째로 결정을 해야한다.
다양한 db가 있지만 몽고DB는 스타트업에서 많이 사용

1.rest에서 다룬 세가지 기능 코드를 고려하여
유연한 코드 설계를 하려면 인터페이스에 정의할 수 있는 앞의 3가지 기능이 필요하게 된다.

//persistence.DatebaseHandler 에 정의

type DatabaseHandler interface{
	AddEvent(Event) ([]byte, error)
	FindEvent([]byte) (Event, error)
	FindEventByName(string) (Event, error)
	FindAllAvailableEvent() ([]Event, error)
}
이 이벤트 데이터 타입은 무엇보다 이벤트 이름, 장소, 시간 같은 이벤트의 데이터를 나타내는 구조체 타입이다.
이 인터페이스는 지속성 계층에서 요구되는 업무들을 표현하는 4가지 메서드를 지원한다. 이후 이 인터페이스로부터 수많은 실제적인 구현을 만들어 낼 수 있다.
하나는 몽고DB
하나는 클라우드 네이티브 AWS, 다이나모 DB 데이터베이스 등


-----------------------------------------------------------------------------------------------------------
6. 앞부분에 생성된 DatabaseHandler 인터페이스를 지원 코드 작성
-----------------------------------------------------------------------------------------------------------
15 -> 인터페이스 지원하기위한 구조체 생성

19 -> 객체를 초기화하고자 생성자를 작성할 필요가 있음

---
25 -> 데이터베이스에 저장된 이벤트들을 질의하는데 사용되는 HTTP 요청에 대한 처리르 담당한다. (ID나 name을 통해 이벤트 질의를 할 수 있다.)
검색 방법 (이는 rest.go 에서 14, 15을 보면 알 수 있다.) -> {SearchCriteria}, {search} 경로에서 2개의 변수다. id나 name으로 대체 가능
1. ID를 검색할 때 요청 URL은 /events/id/3434 와 같이 되고 GET 타입이다.
2. 이름으로 검색할 때 /events/name/jazz_concert와 되고 GET 타입니다.
이 메서드는 2개의 인수를 취한다.
채울 필요가 있는 HTTP 응답을 나타내는 http.ResponseWriter 타입의 객체와 수신한 HTTP 요청을 나타내는 *http.Request 타입의 객체다.
26 -> 인수로 요청. 객체를 가진 mux.Vars()를 사용
이것은 키와 값의 맵을 반환하는데, 요청 URL 변수들과 그 값들을 나타낸다. 
예를 들어 요청 URL이 /events/name/jazz_concert의 형태이면 결과 맵에서 2개의 키-값 쌍을 갖게 된다. 첫 번째 키는 "SearchCriteria"로 "name"의값을 갖고
두 번째 키는 "search"로 jazz_concert의 값을 가진다. 이 결과 맵은 vars 변수에 저장된다.
이후 다음 줄의 맵에서 criteria를 얻는다.
27 -> criteria 변수는 사용자가 올바른 요청 URL을 보냈다면 name이나 id 어느 한쪽을 갖게 될 것이다.
ok변수는 boolean 타입 ok가 참이면 vars 맵에서 SearchCriteria란 키를 찾고 거짓이면 유효하지 않다는 것을 알 수 있음.
28 -> 검색 기준을 가져왔는지 여부를 확인 가져오지 못하면 29~33 에러를 보고 빠져나옴
보통 JSON 바디 포맷을 가진 방식도 RESTful API가 선호되지만 간결함을 위해 JSON 문자열의 철자만을 제시
fmt.Fpring()는 w변수에 직접적으로 에러 메시지를 작성해주며 HTTP 응답 작성기(writer)를 포함
36 -> {search}를 동일하게 처리
45~55 -> URL 변수들을 이용해 데이터베이스에서 정보를 뽑아냄
48, 49 -> NAME 검색 기준의 경우에는 이름으로 검색하기 위해 FindEventByName() 데이터베이스 핸들러 메서드를 사용 
50, 51 -> ID 검색 기준의 경우에는 ID으로 검색하기 위해 hex.DecodeString()을 사용
성공적으로 바이트 슬라이스를 얻는다면 획득된 ID로 FindEvent()를 호출한다.
56 -> 이후 err 객체를 확인해서 데이터베이스 작업 중 어떤 에러가 발생했는지 여부를 확인, 에러를 발견하면 응답에 404 에더 헤더 작성 또는 해당 에러 출력
60 -> 해당 응답을 JSON 포맷으로 변환 -> 따라서 HTTP content-type 헤더를 application/json으로 바꾼다. 
61 -> 이후 데이터베이스 호출에서 획득된 결과들을 JSON 포맷으로 변환하고자 강력한 go JSON 패키지를 사용
----

64 -> HTTP 응답에서 모든 가능한 이벤트를 반환할 것.
65 -> FindAllAvailableEvents()를 호출한다.
이후 어떤 에러들이 발생했는지 여부 확인 및 에러 내용 출력
71, 72 -> 에러가 발생하지 않았다면 이벤트들을 JSON 포맷으로 인코딩

----

79 -> 들어오는 HTTP 요청들에서 가져온 데이터를 사용해 데이터베이스에 새로운 이벤트를 추가한다. 또한 들어오는 HTTP 요청에 있는 이벤트 데이터가 JSON 포맷이기를 기대
80 -> 새로운 객체 생성 ( 들어오는 HTTP 요청에서 구문 분석을 하게 될 데이터를 갖고 있으려고 사용 )
81 -> 들어오는 HTTP 요청의 바디를 취할 Go의 JSON 패키지를 사용한다[r.body를 호출함으로써].
이후 어떤 에러들이 발생했는지 여부 확인 및 에러 내용 출력
에러가 발생 되지 않았다면
87 -> 데이터베이스 핸들러 AddEvent() 호출 후 해당 이벤트 객체를 인수로서 전달한다.
사실상 들어오는 HTTP요청에서 획득한 이벤트 객체를 데이터베이스에 추가 


----

이벤트 마이크로서비스에 마지막 마무리를 하려면 4가지 처리를 해야 한다. 
- 첫 번째는 HTTP 라우트와 핸들러를 정의하는 ServeAPI() 함수가 eventServiceHandler 생성자를 호출할 수 있게 하는 것

- 두 번째 마무리는 마이크로서비스를 위한 구성configuration계층을 작성하는 것.
마이크로서비스에 사용 되는 데이터베이스 타입(몽고DB가 기본 설정), 데이터베이스 연결 문자열(로컬 연결에 대한 기본 설정은 mongodb://127.0.0.1), RESTful API 엔드포인트


